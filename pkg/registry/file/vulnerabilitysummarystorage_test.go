package file

import (
	"context"
	"testing"
	"time"

	"github.com/kubescape/storage/pkg/apis/softwarecomposition"
	"github.com/kubescape/storage/pkg/apis/softwarecomposition/v1beta1"
	"github.com/kubescape/storage/pkg/generated/clientset/versioned/scheme"
	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apiserver/pkg/storage"
	"zombiezen.com/go/sqlite/sqlitemigration"
)

func TestVulnSummaryStorageImpl_Create(t *testing.T) {
	type args struct {
		key string
		obj runtime.Object
		out runtime.Object
		in4 uint64
	}

	tests := []struct {
		name     string
		readonly bool
		args     args
		wantErr  bool
		want     runtime.Object
	}{
		{
			name: "not supported",
			args: args{
				key: "/spdx.softwarecomposition.kubescape.io/vulnerabilitysummaries/kubescape/toto",
				obj: &v1beta1.VulnerabilitySummary{},
			},
			wantErr: true,
		},
	}
	realStorage := NewStorageImpl(afero.NewMemMapFs(), "/", nil, nil)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := NewVulnerabilitySummaryStorage(realStorage)
			err := s.Create(context.TODO(), tt.args.key, tt.args.obj, tt.args.out, tt.args.in4)
			if tt.wantErr {
				assert.Error(t, err)
				assert.Equal(t, err, storage.NewInvalidObjError(tt.args.key, operationNotSupportedMsg))

			}
		})
	}
}

func TestVulnSummaryStorageImpl_Delete(t *testing.T) {
	type args struct {
		key                  string
		obj                  runtime.Object
		precondition         *storage.Preconditions
		validateDeletionFunc storage.ValidateObjectFunc
		cachedObj            runtime.Object
		opts                 storage.DeleteOptions
	}
	tests := []struct {
		name    string
		args    args
		wantErr bool
	}{
		{
			name: "not supported",
			args: args{
				key: "/spdx.softwarecomposition.kubescape.io/vulnerabilitysummaries/kubescape/toto",
			},
			wantErr: true,
		},
	}
	realStorage := NewStorageImpl(afero.NewMemMapFs(), "/", nil, nil)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := NewVulnerabilitySummaryStorage(realStorage)
			err := s.Delete(context.TODO(), tt.args.key, tt.args.obj, tt.args.precondition, tt.args.validateDeletionFunc, tt.args.cachedObj, tt.args.opts)
			if tt.wantErr {
				assert.Error(t, err)
				assert.Equal(t, err, storage.NewInvalidObjError(tt.args.key, operationNotSupportedMsg))

			}
		})
	}
}

func TestVulnSummaryStorageImpl_Watch(t *testing.T) {
	storageImpl := NewStorageImpl(afero.NewMemMapFs(), "", nil, nil)
	vulnerabilitySummaryStorage := NewVulnerabilitySummaryStorage(storageImpl)

	_, err := vulnerabilitySummaryStorage.Watch(context.TODO(), "", storage.ListOptions{})
	assert.NoError(t, err)
}

func TestVulnSummaryStorageImpl_GetList(t *testing.T) {
	type args struct {
		keyExpectedObj string
		expectedObj    *softwarecomposition.VulnerabilitySummaryList
		keyCreatedObj  []string
		createdObj     []*softwarecomposition.VulnerabilityManifestSummary
	}
	tests := []struct {
		name      string
		args      args
		createObj bool
		wantErr   bool
	}{
		{
			name: "get - from one created object",
			args: args{
				keyExpectedObj: "/spdx.softwarecomposition.kubescape.io/vulnerabilitysummaries/any",
				expectedObj: &softwarecomposition.VulnerabilitySummaryList{
					TypeMeta: v1.TypeMeta{
						Kind:       "VulnerabilitySummary",
						APIVersion: "spdx.softwarecomposition.kubescape.io/v1beta1",
					},
					Items: []softwarecomposition.VulnerabilitySummary{
						{
							TypeMeta: v1.TypeMeta{
								Kind:       "VulnerabilitySummary",
								APIVersion: "spdx.softwarecomposition.kubescape.io/v1beta1",
							},
							Spec: softwarecomposition.VulnerabilitySummarySpec{
								WorkloadVulnerabilitiesObj: []softwarecomposition.VulnerabilitiesObjScope{
									{
										Kind: "vulnerabilitymanifestsummary",
									},
								},
							},
						},
					},
				},
				keyCreatedObj: []string{"/spdx.softwarecomposition.kubescape.io/vulnerabilitymanifestsummaries/any/any"},
				createdObj:    []*softwarecomposition.VulnerabilityManifestSummary{{}},
			},
			createObj: true,
			wantErr:   false,
		},
		{
			name: "get - from two created object",
			args: args{
				keyExpectedObj: "/spdx.softwarecomposition.kubescape.io/vulnerabilitysummaries/any",
				expectedObj: &softwarecomposition.VulnerabilitySummaryList{
					TypeMeta: v1.TypeMeta{
						Kind:       "VulnerabilitySummary",
						APIVersion: "spdx.softwarecomposition.kubescape.io/v1beta1",
					},
					Items: []softwarecomposition.VulnerabilitySummary{
						{
							TypeMeta: v1.TypeMeta{
								Kind:       "VulnerabilitySummary",
								APIVersion: "spdx.softwarecomposition.kubescape.io/v1beta1",
							},
							ObjectMeta: v1.ObjectMeta{
								Name: "any",
							},
							Spec: softwarecomposition.VulnerabilitySummarySpec{
								WorkloadVulnerabilitiesObj: []softwarecomposition.VulnerabilitiesObjScope{
									{
										Name:      "any",
										Namespace: "any",
										Kind:      "vulnerabilitymanifestsummary",
									},
								},
							},
						},
						{
							TypeMeta: v1.TypeMeta{
								Kind:       "VulnerabilitySummary",
								APIVersion: "spdx.softwarecomposition.kubescape.io/v1beta1",
							},
							ObjectMeta: v1.ObjectMeta{
								Name: "many",
							},
							Spec: softwarecomposition.VulnerabilitySummarySpec{
								WorkloadVulnerabilitiesObj: []softwarecomposition.VulnerabilitiesObjScope{
									{
										Kind:      "vulnerabilitymanifestsummary",
										Name:      "any",
										Namespace: "many",
									},
								},
							},
						},
					},
				},
				keyCreatedObj: []string{"/spdx.softwarecomposition.kubescape.io/vulnerabilitymanifestsummaries/any/any", "/spdx.softwarecomposition.kubescape.io/vulnerabilitymanifestsummaries/many/any"},
				createdObj: []*softwarecomposition.VulnerabilityManifestSummary{
					{
						ObjectMeta: v1.ObjectMeta{
							Name:      "any",
							Namespace: "any",
						},
						Spec: softwarecomposition.VulnerabilityManifestSummarySpec{
							Severities: softwarecomposition.SeveritySummary{
								Negligible: softwarecomposition.VulnerabilityCounters{
									All:      1,
									Relevant: 0,
								},
							},
						},
					},
					{
						ObjectMeta: v1.ObjectMeta{
							Name:      "any",
							Namespace: "many",
						},
						Spec: softwarecomposition.VulnerabilityManifestSummarySpec{
							Severities: softwarecomposition.SeveritySummary{
								Critical: softwarecomposition.VulnerabilityCounters{
									All:      1,
									Relevant: 0,
								},
							},
						},
					},
				},
			},
			createObj: true, wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Logf("expected scope on entry: %v", tt.args.expectedObj.Items)
			pool := NewTestPool(t.TempDir())
			require.NotNil(t, pool)
			defer func(pool *sqlitemigration.Pool) {
				_ = pool.Close()
			}(pool)
			sch := scheme.Scheme
			require.NoError(t, softwarecomposition.AddToScheme(sch))
			realStorage := NewStorageImpl(afero.NewMemMapFs(), "/", pool, sch)
			ctx, cancel := context.WithTimeout(context.TODO(), 5*time.Second)
			defer cancel()
			if tt.createObj {
				for i, obj := range tt.args.createdObj {
					err := realStorage.Create(ctx, tt.args.keyCreatedObj[i], obj, nil, 0)
					require.NoError(t, err)
				}
			}
			s := NewVulnerabilitySummaryStorage(realStorage)
			o := &softwarecomposition.VulnerabilitySummaryList{}
			err := s.GetList(ctx, tt.args.keyExpectedObj, storage.ListOptions{}, o)
			if tt.wantErr {
				assert.Error(t, err)
				assert.Equal(t, err, storage.NewKeyNotFoundError(tt.name, 0))
			} else {
				assert.NoError(t, err)
				for i := range o.Items {
					// copy the timestamp since it is created when generated, so it can be known at the test begin
					o.Items[i].CreationTimestamp = tt.args.createdObj[i].CreationTimestamp
				}
				assert.Equal(t, tt.args.expectedObj.TypeMeta, o.TypeMeta)
				assert.Equal(t, tt.args.expectedObj.ListMeta, o.ListMeta)
				assert.ElementsMatch(t, tt.args.expectedObj.Items, o.Items)
			}
		})
	}
}

func TestVulnSummaryStorageImpl_GuaranteedUpdate(t *testing.T) {
	type args struct {
		key                  string
		obj                  runtime.Object
		preconditions        *storage.Preconditions
		tryUpdate            storage.UpdateFunc
		cachedExistingObject runtime.Object
	}
	tests := []struct {
		name    string
		args    args
		wantErr bool
	}{
		{
			name: "not supported",
			args: args{
				key: "/spdx.softwarecomposition.kubescape.io/vulnerabilitysummaries/kubescape/toto",
			},
			wantErr: true,
		},
	}

	realStorage := NewStorageImpl(afero.NewMemMapFs(), "/", nil, nil)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := NewVulnerabilitySummaryStorage(realStorage)
			err := s.GuaranteedUpdate(context.TODO(), tt.args.key, tt.args.obj, true, tt.args.preconditions, tt.args.tryUpdate, tt.args.cachedExistingObject)
			if tt.wantErr {
				assert.Error(t, err)
				assert.Equal(t, err, storage.NewInvalidObjError(tt.args.key, operationNotSupportedMsg))

			}
		})
	}
}

func TestVulnSummaryStorageImpl_Count(t *testing.T) {
	type args struct {
		key string
	}
	tests := []struct {
		name    string
		args    args
		wantErr bool
	}{
		{
			name: "not supported",
			args: args{
				key: "/spdx.softwarecomposition.kubescape.io/vulnerabilitysummaries/kubescape/toto",
			},
			wantErr: true,
		},
	}
	realStorage := NewStorageImpl(afero.NewMemMapFs(), "/", nil, nil)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := NewVulnerabilitySummaryStorage(realStorage)
			_, err := s.Count(tt.args.key)
			if tt.wantErr {
				assert.Error(t, err)
				assert.Equal(t, err, storage.NewInvalidObjError(tt.args.key, operationNotSupportedMsg))

			}
		})
	}
}

func TestVulnSummaryStorageImpl_Get(t *testing.T) {
	type args struct {
		keyExpectedObj string
		expectedObj    *softwarecomposition.VulnerabilitySummary
		keyCreatedObj  []string
		createdObj     []*softwarecomposition.VulnerabilityManifestSummary
	}
	tests := []struct {
		name      string
		args      args
		createObj bool
		wantErr   bool
	}{
		{
			name: "get - from one created object",
			args: args{
				keyExpectedObj: "/spdx.softwarecomposition.kubescape.io/vulnerabilitysummaries/any",
				expectedObj: &softwarecomposition.VulnerabilitySummary{
					TypeMeta: v1.TypeMeta{
						Kind:       "VulnerabilitySummary",
						APIVersion: "spdx.softwarecomposition.kubescape.io/v1beta1",
					},
					ObjectMeta: v1.ObjectMeta{
						Name: "any",
					},
					Spec: softwarecomposition.VulnerabilitySummarySpec{
						WorkloadVulnerabilitiesObj: []softwarecomposition.VulnerabilitiesObjScope{
							{
								Kind: "vulnerabilitymanifestsummary",
							},
						},
					},
				},
				keyCreatedObj: []string{"/spdx.softwarecomposition.kubescape.io/vulnerabilitymanifestsummaries/any/any"},
				createdObj:    []*softwarecomposition.VulnerabilityManifestSummary{{}},
			},
			createObj: true, wantErr: false,
		},
		{
			name: "get - from two created object",
			args: args{
				keyExpectedObj: "/spdx.softwarecomposition.kubescape.io/vulnerabilitysummaries/any",
				expectedObj: &softwarecomposition.VulnerabilitySummary{
					TypeMeta: v1.TypeMeta{
						Kind:       "VulnerabilitySummary",
						APIVersion: "spdx.softwarecomposition.kubescape.io/v1beta1",
					},
					ObjectMeta: v1.ObjectMeta{
						Name: "any",
					},
					Spec: softwarecomposition.VulnerabilitySummarySpec{
						WorkloadVulnerabilitiesObj: []softwarecomposition.VulnerabilitiesObjScope{
							{
								Kind: "vulnerabilitymanifestsummary",
							},
							{
								Kind: "vulnerabilitymanifestsummary",
							},
						},
					},
				},
				keyCreatedObj: []string{"/spdx.softwarecomposition.kubescape.io/vulnerabilitymanifestsummaries/any/any", "/spdx.softwarecomposition.kubescape.io/vulnerabilitymanifestsummaries/any/many"},
				createdObj:    []*softwarecomposition.VulnerabilityManifestSummary{{}, {}},
			},
			createObj: true, wantErr: false,
		},
	}
	pool := NewTestPool(t.TempDir())
	require.NotNil(t, pool)
	defer func(pool *sqlitemigration.Pool) {
		_ = pool.Close()
	}(pool)
	sch := scheme.Scheme
	require.NoError(t, softwarecomposition.AddToScheme(sch))

	for _, tt := range tests {
		realStorage := NewStorageImpl(afero.NewMemMapFs(), "/", pool, sch)
		t.Run(tt.name, func(t *testing.T) {
			ctx, cancel := context.WithTimeout(context.TODO(), 5*time.Second)
			defer cancel()
			if tt.createObj {
				for i := range tt.args.keyCreatedObj {
					err := realStorage.Create(ctx, tt.args.keyCreatedObj[i], tt.args.createdObj[i], nil, 0)
					require.NoError(t, err)
				}
			}
			s := NewVulnerabilitySummaryStorage(realStorage)
			o := &softwarecomposition.VulnerabilitySummary{}
			err := s.Get(ctx, tt.args.keyExpectedObj, storage.GetOptions{}, o)
			if tt.wantErr {
				assert.Error(t, err)
				assert.Equal(t, err, storage.NewKeyNotFoundError(tt.name, 0))

			} else {
				assert.NoError(t, err)
				// copy the timestamp since it is created when generated, so it can be known at the test begin
				tt.args.expectedObj.CreationTimestamp = o.CreationTimestamp
				assert.Equal(t, tt.args.expectedObj, o)
			}
		})
	}
}
