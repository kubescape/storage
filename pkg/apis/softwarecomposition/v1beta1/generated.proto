/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.kubescape.storage.pkg.apis.softwarecomposition.v1beta1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "github.com/kubescape/storage/pkg/apis/softwarecomposition/v1beta1";

message Advisory {
  optional string id = 1;

  optional string link = 2;
}

message ApplicationActivity {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ApplicationActivitySpec spec = 2;

  optional ApplicationActivityStatus status = 3;
}

message ApplicationActivityList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ApplicationActivity items = 2;
}

message ApplicationActivitySpec {
  repeated string syscalls = 1;
}

message ApplicationActivityStatus {
}

message ApplicationProfile {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ApplicationProfileSpec spec = 2;

  optional ApplicationProfileStatus status = 3;
}

message ApplicationProfileContainer {
  optional string name = 1;

  repeated string capabilities = 2;

  // +patchMergeKey=path
  // +patchStrategy=merge
  repeated ExecCalls execs = 3;

  // +patchMergeKey=path
  // +patchStrategy=merge
  repeated OpenCalls opens = 4;

  repeated string syscalls = 5;

  optional SingleSeccompProfile seccompProfile = 6;

  // +patchStrategy=merge
  // +patchMergeKey=endpoint
  repeated HTTPEndpoint endpoints = 7;

  optional string imageID = 8;

  optional string imageTag = 9;

  // +patchStrategy=merge
  // +patchMergeKey=ruleId
  map<string, RulePolicy> rulePolicies = 10;

  repeated IdentifiedCallStack identifiedCallStacks = 11;
}

message ApplicationProfileList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ApplicationProfile items = 2;
}

message ApplicationProfileSpec {
  repeated string architectures = 1;

  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated ApplicationProfileContainer containers = 2;

  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated ApplicationProfileContainer initContainers = 3;

  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated ApplicationProfileContainer ephemeralContainers = 4;
}

message ApplicationProfileStatus {
}

// Arg defines the specific syscall in seccomp.
message Arg {
  // the index for syscall arguments in seccomp
  optional uint64 index = 1;

  // the value for syscall arguments in seccomp
  optional uint64 value = 2;

  // the value for syscall arguments in seccomp
  optional uint64 valueTwo = 3;

  // the operator for syscall arguments in seccomp
  optional string op = 4;
}

message CPE {
  optional string cpe = 1;

  optional string source = 2;
}

message CallStack {
  optional CallStackNode root = 1;
}

message CallStackNode {
  repeated CallStackNode children = 1;

  optional CallStackNode parent = 2;

  optional StackFrame frame = 3;
}

message Component {
  // ID is an IRI identifying the component. It is optional as the component
  // can also be identified using hashes or software identifiers.
  optional string id = 1;

  // Hashes is a map of hashes to identify the component using cryptographic
  // hashes.
  map<string, string> hashes = 2;

  // Identifiers is a list of software identifiers that describe the component.
  map<string, string> identifiers = 3;

  // Supplier is an optional machine-readable identifier for the supplier of
  // the component. Valid examples include email address or IRIs.
  optional string supplier = 4;
}

message Condition {
  // Type of this condition. At most one of each condition type may apply to
  // a resource at any point in time.
  optional string type = 1;

  // Status of this condition; is it currently True, False, or Unknown?
  optional string status = 2;

  // LastTransitionTime is the last time this condition transitioned from one
  // status to another.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // A Reason for this condition's last transition from one status to another.
  optional string reason = 4;

  // A Message containing details about this condition's last transition from
  // one status to another, if any.
  // +optional
  optional string message = 5;
}

message ConditionedStatus {
  // Conditions of the resource.
  // +optional
  repeated Condition conditions = 1;
}

// ConfigurationScanSummary is a summary for a group of WorkloadConfigurationScanSummary objects for a given scope (ex. namespace).
message ConfigurationScanSummary {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional ConfigurationScanSummarySpec spec = 2;
}

// ConfigurationScanSummaryList is a list of ConfigurationScanSummary summaries.
message ConfigurationScanSummaryList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ConfigurationScanSummary items = 2;
}

message ConfigurationScanSummarySpec {
  optional WorkloadConfigurationScanSeveritiesSummary severities = 1;

  repeated WorkloadConfigurationScanSummaryIdentifier summaryRef = 2;
}

message ControlSeverity {
  optional string severity = 1;

  optional float scoreFactor = 2;
}

// Coordinates contains the minimal information needed to describe how to find a file within any possible source object (e.g. image and directory sources)
message Coordinates {
  optional string path = 1;

  // The path where all path ancestors have no hardlinks / symlinks
  optional string layerID = 2;
}

message Cvss {
  optional string version = 1;

  optional string vector = 2;

  optional CvssMetrics metrics = 3;

  optional bytes vendorMetadata = 4;
}

message CvssMetrics {
  optional double baseScore = 1;

  optional double exploitabilityScore = 2;

  optional double impactScore = 3;
}

message Descriptor {
  optional string name = 1;

  optional string version = 2;

  optional bytes configuration = 3;

  optional bytes db = 4;
}

message Digest {
  optional string algorithm = 1;

  optional string value = 2;
}

message Distribution {
  optional string name = 1;

  optional string version = 2;

  repeated string idLike = 3;
}

message ELFSecurityFeatures {
  optional bool symbolTableStripped = 1;

  optional bool stackCanary = 2;

  optional bool nx = 3;

  optional string relRO = 4;

  optional bool pie = 5;

  optional bool dso = 6;

  // LlvmSafeStack represents a compiler-based security mechanism that separates the stack into a safe stack for storing return addresses and other critical data, and an unsafe stack for everything else, to mitigate stack-based memory corruption errors
  // see https://clang.llvm.org/docs/SafeStack.html
  optional bool safeStack = 7;

  // ControlFlowIntegrity represents runtime checks to ensure a program's control flow adheres to the legal paths determined at compile time, thus protecting against various types of control-flow hijacking attacks
  // see https://clang.llvm.org/docs/ControlFlowIntegrity.html
  optional bool cfi = 8;

  // ClangFortifySource is a broad suite of extensions to libc aimed at catching misuses of common library functions
  // see https://android.googlesource.com/platform//bionic/+/d192dbecf0b2a371eb127c0871f77a9caf81c4d2/docs/clang_fortify_anatomy.md
  optional bool fortify = 9;
}

message ExecCalls {
  optional string path = 1;

  repeated string args = 2;

  repeated string envs = 3;
}

message Executable {
  // Format denotes either ELF, Mach-O, or PE
  optional string format = 1;

  optional bool hasExports = 2;

  optional bool hasEntrypoint = 3;

  repeated string importedLibraries = 4;

  optional ELFSecurityFeatures elfSecurityFeatures = 5;
}

message FileLicense {
  optional string value = 1;

  optional string spdxExpression = 2;

  optional string type = 3;

  optional FileLicenseEvidence evidence = 4;
}

message FileLicenseEvidence {
  optional int64 confidence = 1;

  optional int64 offset = 2;

  optional int64 extent = 3;
}

message FileMetadataEntry {
  optional int64 mode = 1;

  optional string type = 2;

  optional string linkDestination = 3;

  optional int64 userID = 4;

  optional int64 groupID = 5;

  optional string mimeType = 6;

  optional int64 size = 7;
}

message Fix {
  repeated string versions = 1;

  optional string state = 2;
}

// GeneratedNetworkPolicy represents a generated NetworkPolicy.
message GeneratedNetworkPolicy {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional NetworkPolicy spec = 2;

  repeated PolicyRef policyRef = 3;
}

// GeneratedNetworkPolicyList is a list of GeneratedNetworkPolicies.
message GeneratedNetworkPolicyList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated GeneratedNetworkPolicy items = 2;
}

// GrypeDocument is the document that represents the vulnerability manifest in
// the Grype’s JSON format
message GrypeDocument {
  repeated Match matches = 1;

  repeated IgnoredMatch ignoredMatches = 2;

  optional Source source = 3;

  optional Distribution distro = 4;

  optional Descriptor descriptor = 5;
}

message GrypePackage {
  optional string name = 1;

  optional string version = 2;

  optional string type = 3;

  repeated SyftCoordinates locations = 4;

  optional string language = 5;

  repeated string licenses = 6;

  repeated string cpes = 7;

  optional string purl = 8;

  repeated UpstreamPackage upstreams = 9;

  optional string metadataType = 10;

  optional bytes metadata = 11;
}

message HTTPEndpoint {
  optional string endpoint = 1;

  repeated string methods = 2;

  optional bool internal = 3;

  optional string direction = 4;

  optional bytes headers = 5;
}

// HTTPIngressPath associates a path with a backend. Incoming urls matching the
// path are forwarded to the backend.
message HTTPIngressPath {
  optional string path = 1;

  // pathType determines the interpretation of the path matching. PathType can
  // be one of the following values:
  // * Exact: Matches the URL path exactly.
  // * Prefix: Matches based on a URL path prefix split by '/'. Matching is
  //   done on a path element by element basis. A path element refers is the
  //   list of labels in the path split by the '/' separator. A request is a
  //   match for path p if every p is an element-wise prefix of p of the
  //   request path. Note that if the last element of the path is a substring
  //   of the last element in request path, it is not a match (e.g. /foo/bar
  //   matches /foo/bar/baz, but does not match /foo/barbaz).
  // * ImplementationSpecific: Interpretation of the Path matching is up to
  //   the IngressClass. Implementations can treat this as a separate PathType
  //   or treat it identically to Prefix or Exact path types.
  // Implementations are required to support all path types.
  optional string pathType = 3;

  // backend defines the referenced service endpoint to which the traffic
  // will be forwarded to.
  optional IngressBackend backend = 2;
}

// HTTPIngressRuleValue is a list of http selectors pointing to backends.
// In the example: http://<host>/<path>?<searchpart> -> backend where
// where parts of the url correspond to RFC 3986, this resource will be used
// to match against everything after the last '/' and before the first '?'
// or '#'.
message HTTPIngressRuleValue {
  // paths is a collection of paths that map requests to backends.
  // +listType=atomic
  repeated HTTPIngressPath paths = 1;
}

// IPBlock describes a particular CIDR (Ex. "192.168.1.0/24","2001:db8::/64") that is allowed
// to the pods matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs
// that should not be included within this rule.
message IPBlock {
  // cidr is a string representing the IPBlock
  // Valid examples are "192.168.1.0/24" or "2001:db8::/64"
  optional string cidr = 1;

  repeated string except = 2;
}

message IdentifiedCallStack {
  optional string callID = 1;

  optional CallStack callStack = 2;
}

message IgnoreRule {
  optional string vulnerability = 1;

  optional string fixstate = 2;

  optional IgnoreRulePackage package = 3;
}

message IgnoreRulePackage {
  optional string name = 1;

  optional string version = 2;

  optional string type = 3;

  optional string location = 4;

  optional string upstreamname = 5;
}

message IgnoredMatch {
  optional Match match = 1;

  repeated IgnoreRule appliedIgnoreRules = 2;
}

// Ingress is a collection of rules that allow inbound connections to reach the
// endpoints defined by a backend. An Ingress can be configured to give services
// externally-reachable urls, load balance traffic, terminate SSL, offer name
// based virtual hosting etc.
message Ingress {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional IngressSpec spec = 2;

  optional IngressStatus status = 3;
}

// IngressBackend describes all endpoints for a given service and port.
message IngressBackend {
  optional IngressServiceBackend service = 4;

  optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;
}

// IngressClass represents the class of the Ingress, referenced by the Ingress
// Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be
// used to indicate that an IngressClass should be considered default. When a
// single IngressClass resource has this annotation set to true, new Ingress
// resources without a class specified will be assigned this default class.
message IngressClass {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional IngressClassSpec spec = 2;
}

// IngressClassList is a collection of IngressClasses.
message IngressClassList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  // items is the list of IngressClasses.
  repeated IngressClass items = 2;
}

// IngressClassParametersReference identifies an API object. This can be used
// to specify a cluster or namespace-scoped resource.
message IngressClassParametersReference {
  optional string aPIGroup = 1;

  // kind is the type of resource being referenced.
  optional string kind = 2;

  // name is the name of resource being referenced.
  optional string name = 3;

  optional string scope = 4;

  optional string namespace = 5;
}

// IngressClassSpec provides information about the class of an Ingress.
message IngressClassSpec {
  // controller refers to the name of the controller that should handle this
  // class. This allows for different "flavors" that are controlled by the
  // same controller. For example, you may have different parameters for the
  // same implementing controller. This should be specified as a
  // domain-prefixed path no more than 250 characters in length, e.g.
  // "acme.io/ingress-controller". This field is immutable.
  optional string controller = 1;

  optional IngressClassParametersReference parameters = 2;
}

// IngressList is a collection of Ingress.
message IngressList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  // items is the list of Ingress.
  repeated Ingress items = 2;
}

// IngressLoadBalancerIngress represents the status of a load-balancer ingress point.
message IngressLoadBalancerIngress {
  optional string ip = 1;

  optional string hostname = 2;

  repeated IngressPortStatus ports = 4;
}

// IngressLoadBalancerStatus represents the status of a load-balancer.
message IngressLoadBalancerStatus {
  repeated IngressLoadBalancerIngress ingress = 1;
}

// IngressPortStatus represents the error condition of a service port
message IngressPortStatus {
  // port is the port number of the ingress port.
  optional int32 port = 1;

  // protocol is the protocol of the ingress port.
  // The supported values are: "TCP", "UDP", "SCTP"
  optional string protocol = 2;

  // +kubebuilder:validation:Required
  // +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
  // +kubebuilder:validation:MaxLength=316
  optional string error = 3;
}

// IngressRule represents the rules mapping the paths under a specified host to
// the related backend services. Incoming requests are first evaluated for a host
// match, then routed to the backend associated with the matching IngressRuleValue.
message IngressRule {
  optional string host = 1;

  optional IngressRuleValue ingressRuleValue = 2;
}

// IngressRuleValue represents a rule to apply against incoming requests. If the
// rule is satisfied, the request is routed to the specified backend. Currently
// mixing different types of rules in a single Ingress is disallowed, so exactly
// one of the following must be set.
message IngressRuleValue {
  optional HTTPIngressRuleValue http = 1;
}

// IngressServiceBackend references a Kubernetes Service as a Backend.
message IngressServiceBackend {
  // name is the referenced service. The service must exist in
  // the same namespace as the Ingress object.
  optional string name = 1;

  // port of the referenced service. A port name or port number
  // is required for a IngressServiceBackend.
  optional ServiceBackendPort port = 2;
}

// IngressSpec describes the Ingress the user wishes to exist.
message IngressSpec {
  optional string ingressClassName = 4;

  optional IngressBackend defaultBackend = 1;

  repeated IngressTLS tls = 2;

  repeated IngressRule rules = 3;
}

// IngressStatus describe the current state of the Ingress.
message IngressStatus {
  optional IngressLoadBalancerStatus loadBalancer = 1;
}

// IngressTLS describes the transport layer security associated with an ingress.
message IngressTLS {
  repeated string hosts = 1;

  optional string secretName = 2;
}

// KnownServer represents a known server, containing information about its IP addresses and servers. The purpose is to enrich the GeneratedNetworkPolicy CRD
message KnownServer {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  repeated KnownServerEntry spec = 2;
}

message KnownServerEntry {
  optional string ipBlock = 1;

  optional string server = 2;

  optional string name = 3;
}

// KnownServerList is a list of KnownServer.
message KnownServerList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated KnownServer items = 2;
}

message License {
  optional string value = 1;

  optional string spdxExpression = 2;

  optional string type = 3;

  repeated string urls = 4;

  repeated Location locations = 5;
}

message LinuxRelease {
  optional string prettyName = 1;

  optional string name = 2;

  optional string id = 3;

  repeated string idLike = 4;

  optional string version = 5;

  optional string versionID = 6;

  optional string versionCodename = 7;

  optional string buildID = 8;

  optional string imageID = 9;

  optional string imageVersion = 10;

  optional string variant = 11;

  optional string variantID = 12;

  optional string homeURL = 13;

  optional string supportURL = 14;

  optional string bugReportURL = 15;

  optional string privacyPolicyURL = 16;

  optional string cpeName = 17;

  optional string supportEnd = 18;
}

// Location represents a path relative to a particular filesystem resolved to a specific file.Reference. This struct is used as a key
// in content fetching to uniquely identify a file relative to a request (the VirtualPath).
message Location {
  optional LocationData locationData = 1;

  optional LocationMetadata locationMetadata = 2;
}

message LocationData {
  optional Coordinates coordinates = 1;

  // note: it is IMPORTANT to ignore anything but the coordinates for a Location when considering the ID (hash value)
  // since the coordinates are the minimally correct ID for a location (symlinks should not come into play)
  optional string accessPath = 2;
}

message LocationMetadata {
  map<string, string> annotations = 1;
}

message Match {
  optional Vulnerability vulnerability = 1;

  repeated VulnerabilityMetadata relatedVulnerabilities = 2;

  repeated MatchDetails matchDetails = 3;

  optional GrypePackage artifact = 4;
}

message MatchDetails {
  optional string type = 1;

  optional string matcher = 2;

  optional bytes searchedBy = 3;

  optional bytes found = 4;
}

message Metadata {
  // Context is the URL pointing to the jsonld context definition
  optional string context = 1;

  // ID is the identifying string for the VEX document. This should be unique per
  // document.
  optional string id = 2;

  // Author is the identifier for the author of the VEX statement, ideally a common
  // name, may be a URI. [author] is an individual or organization. [author]
  // identity SHOULD be cryptographically associated with the signature of the VEX
  // statement or document or transport.
  optional string author = 3;

  // AuthorRole describes the role of the document Author.
  optional string role = 4;

  // Timestamp defines the time at which the document was issued.
  optional string timestamp = 5;

  // LastUpdated marks the time when the document had its last update. When the
  // document changes both version and this field should be updated.
  optional string last_updated = 6;

  // Version is the document version. It must be incremented when any content
  // within the VEX document changes, including any VEX statements included within
  // the VEX document.
  optional int64 version = 7;

  // Tooling expresses how the VEX document and contained VEX statements were
  // generated. It's optional. It may specify tools or automated processes used in
  // the document or statement generation.
  optional string tooling = 8;

  // Supplier is an optional field.
  optional string supplier = 9;
}

// NetworkNeighbor represents a single network communication made by this resource.
message NetworkNeighbor {
  optional string identifier = 1;

  // A unique identifier for this entry
  optional string type = 2;

  optional string dns = 3;

  // DEPRECATED - use DNSNames instead.
  repeated string dnsNames = 4;

  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated NetworkPort ports = 5;

  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 6;

  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 7;

  optional string ipAddress = 8;
}

// NetworkNeighborhood represents a list of network communications for a specific workload.
message NetworkNeighborhood {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional NetworkNeighborhoodSpec spec = 2;
}

message NetworkNeighborhoodContainer {
  optional string name = 1;

  repeated NetworkNeighbor ingress = 2;

  repeated NetworkNeighbor egress = 3;
}

// NetworkNeighborhoodList is a list of NetworkNeighborhoods.
message NetworkNeighborhoodList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated NetworkNeighborhood items = 2;
}

message NetworkNeighborhoodSpec {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 3;

  repeated NetworkNeighborhoodContainer containers = 4;

  repeated NetworkNeighborhoodContainer initContainers = 5;

  repeated NetworkNeighborhoodContainer ephemeralContainers = 6;
}

// NetworkNeighbors represents a list of network communications for a specific workload.
// DEPRECATED - use NetworkNeighborhood instead.
message NetworkNeighbors {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional NetworkNeighborsSpec spec = 2;
}

// NetworkNeighborsList is a list of NetworkNeighbors.
// DEPRECATED - use NetworkNeighborhoodList instead.
message NetworkNeighborsList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated NetworkNeighbors items = 2;
}

message NetworkNeighborsSpec {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 3;

  // +patchMergeKey=identifier
  // +patchStrategy=merge
  repeated NetworkNeighbor ingress = 4;

  // +patchMergeKey=identifier
  // +patchStrategy=merge
  repeated NetworkNeighbor egress = 5;
}

message NetworkPolicy {
  optional string kind = 1;

  optional string apiVersion = 2;

  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 3;

  optional NetworkPolicySpec spec = 4;
}

// NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods
// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to.
// This type is beta-level in 1.8
message NetworkPolicyEgressRule {
  repeated NetworkPolicyPort ports = 1;

  repeated NetworkPolicyPeer to = 2;
}

// NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods
// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.
message NetworkPolicyIngressRule {
  repeated NetworkPolicyPort ports = 1;

  repeated NetworkPolicyPeer from = 2;
}

// NetworkPolicyList is a list of NetworkPolicy objects.
message NetworkPolicyList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  // items is a list of schema objects.
  repeated NetworkPolicy items = 2;
}

// NetworkPolicyPeer describes a peer to allow traffic to/from. Only certain combinations of
// fields are allowed
message NetworkPolicyPeer {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;

  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;

  optional IPBlock ipBlock = 3;
}

// NetworkPolicyPort describes a port to allow traffic on
message NetworkPolicyPort {
  optional string protocol = 1;

  optional int32 port = 2;

  optional int32 endPort = 3;
}

// NetworkPolicySpec provides the specification of a NetworkPolicy
message NetworkPolicySpec {
  // podSelector selects the pods to which this NetworkPolicy object applies.
  // The array of ingress rules is applied to any pods selected by this field.
  // Multiple network policies can select the same set of pods. In this case,
  // the ingress rules for each are combined additively.
  // This field is NOT optional and follows standard label selector semantics.
  // An empty podSelector matches all pods in this namespace.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;

  repeated NetworkPolicyIngressRule ingress = 2;

  repeated NetworkPolicyEgressRule egress = 3;

  repeated string policyTypes = 4;
}

// NetworkPolicyStatus describes the current state of the NetworkPolicy.
message NetworkPolicyStatus {
  // +patchMergeKey=type
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=type
  repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 1;
}

message NetworkPort {
  optional string name = 1;

  // protocol-port
  optional string protocol = 2;

  optional int32 port = 3;
}

message OpenCalls {
  optional string path = 1;

  repeated string flags = 2;
}

message OpenVulnerabilityExchangeContainer {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional VEX spec = 2;
}

message OpenVulnerabilityExchangeContainerList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated OpenVulnerabilityExchangeContainer items = 2;
}

// PackageBasicData contains non-ambiguous values (type-wise) from pkg.SyftPackage.
message PackageBasicData {
  optional string id = 1;

  optional string name = 2;

  optional string version = 3;

  optional string type = 4;

  optional string foundBy = 5;

  repeated Location locations = 6;

  repeated License licenses = 7;

  optional string language = 8;

  repeated CPE cpes = 9;

  optional string purl = 10;
}

// PackageBasicDataV01011 is the previous version of PackageBasicData used in schema v0.101.1.
message PackageBasicDataV01011 {
  optional string id = 1;

  optional string name = 2;

  optional string version = 3;

  optional string type = 4;

  optional string foundBy = 5;

  repeated Location locations = 6;

  repeated License licenses = 7;

  optional string language = 8;

  repeated string cpes = 9;

  optional string purl = 10;
}

// PackageCustomData contains ambiguous values (type-wise) from pkg.SyftPackage.
message PackageCustomData {
  optional string metadataType = 1;

  optional bytes metadata = 2;
}

message PolicyRef {
  optional string ipBlock = 1;

  optional string originalIP = 2;

  optional string dns = 3;

  optional string name = 4;

  optional string server = 5;
}

message Product {
  optional Component component = 1;

  repeated Subcomponent subcomponents = 2;
}

// ReportMeta describes metadata about a report
message ReportMeta {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time createdAt = 1;
}

message RulePath {
  optional string failedPath = 1;

  optional string fixPath = 2;

  optional string fixPathValue = 3;

  optional string fixCommand = 4;
}

message RulePolicy {
  // +patchStrategy=merge
  // +listType=atomic
  repeated string processAllowed = 1;

  optional bool containerAllowed = 2;
}

message RuleStatus {
  optional string status = 1;

  optional string subStatus = 2;
}

// SBOMSyft is a custom resource that describes an SBOM in the Syft format.
message SBOMSyft {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional SBOMSyftSpec spec = 2;

  optional SBOMSyftStatus status = 3;
}

// SBOMSyftFiltered is a custom resource that describes a filtered SBOM in the Syft format.
//
// Being filtered means that the SBOM contains only the relevant vulnerable materials.
message SBOMSyftFiltered {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional SBOMSyftSpec spec = 2;

  optional SBOMSyftStatus status = 3;
}

// SBOMSyftFilteredList is a list of SBOMSyftFiltered objects.
message SBOMSyftFilteredList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated SBOMSyftFiltered items = 2;
}

// SBOMSyftList is a list of SBOMSyft objects.
message SBOMSyftList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated SBOMSyft items = 2;
}

// SBOMSyftSpec is the specification of a Syft SBOM
message SBOMSyftSpec {
  optional SPDXMeta metadata = 1;

  optional SyftDocument syft = 2;
}

// SBOMSyftStatus is the status of a Syft SBOM.
message SBOMSyftStatus {
}

// SPDXMeta describes metadata about an SPDX-formatted SBOM
message SPDXMeta {
  optional ToolMeta tool = 1;

  optional ReportMeta report = 2;
}

message ScannedControl {
  optional string controlID = 1;

  optional string name = 2;

  optional ControlSeverity severity = 3;

  optional ScannedControlStatus status = 4;

  repeated ScannedControlRule rules = 5;
}

message ScannedControlRule {
  optional string name = 1;

  optional RuleStatus status = 2;

  map<string, bytes> controlConfigurations = 3;

  repeated RulePath paths = 4;

  repeated string appliedIgnoreRules = 5;

  repeated string relatedResourcesIDs = 6;
}

message ScannedControlStatus {
  optional string status = 1;

  optional string subStatus = 2;

  optional string info = 3;
}

message ScannedControlSummary {
  optional string controlID = 1;

  optional ControlSeverity severity = 2;

  optional ScannedControlStatus status = 3;
}

message Schema {
  optional string version = 1;

  optional string url = 2;
}

message SeccompProfile {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional SeccompProfileSpec spec = 2;

  optional SeccompProfileStatus status = 3;
}

message SeccompProfileList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated SeccompProfile items = 2;
}

message SeccompProfileSpec {
  repeated SingleSeccompProfile containers = 1;

  repeated SingleSeccompProfile initContainers = 2;

  repeated SingleSeccompProfile ephemeralContainers = 3;
}

message SeccompProfileStatus {
  map<string, SingleSeccompProfileStatus> containers = 1;
}

// ServiceBackendPort is the service port being referenced.
message ServiceBackendPort {
  optional string name = 1;

  optional int32 number = 2;
}

// SeveritySummary is a summary of all vulnerabilities included in vulnerability manifest
message SeveritySummary {
  optional VulnerabilityCounters critical = 1;

  optional VulnerabilityCounters high = 2;

  optional VulnerabilityCounters medium = 3;

  optional VulnerabilityCounters low = 4;

  optional VulnerabilityCounters negligible = 5;

  optional VulnerabilityCounters unknown = 6;
}

message SingleSeccompProfile {
  optional string name = 1;

  optional string path = 2;

  optional SingleSeccompProfileSpec spec = 3;
}

message SingleSeccompProfileSpec {
  // Common spec fields for all profiles.
  optional SpecBase specBase = 1;

  // BaseProfileName is the name of base profile (in the same namespace) that
  // will be unioned into this profile. Base profiles can be references as
  // remote OCI artifacts as well when prefixed with `oci://`.
  optional string baseProfileName = 2;

  // the default action for seccomp
  optional string defaultAction = 3;

  // the architecture used for system calls
  repeated string architectures = 4;

  // path of UNIX domain socket to contact a seccomp agent for SCMP_ACT_NOTIFY
  optional string listenerPath = 5;

  // opaque data to pass to the seccomp agent
  optional string listenerMetadata = 6;

  // match a syscall in seccomp. While this property is OPTIONAL, some values
  // of defaultAction are not useful without syscalls entries. For example,
  // if defaultAction is SCMP_ACT_KILL and syscalls is empty or unset, the
  // kernel will kill the container process on its first syscall
  repeated Syscall syscalls = 7;

  // list of flags to use with seccomp(2)
  repeated string flags = 8;
}

message SingleSeccompProfileStatus {
  optional StatusBase statusBase = 1;

  optional string path = 2;

  repeated string activeWorkloads = 3;

  // The path that should be provided to the `securityContext.seccompProfile.localhostProfile`
  // field of a Pod or container spec
  optional string localhostProfile = 4;
}

message Source {
  optional string type = 1;

  optional bytes target = 2;
}

message SpecBase {
  optional bool disabled = 1;
}

message StackFrame {
  optional uint64 fileID = 1;

  optional uint64 lineno = 2;
}

message Statement {
  // ID is an optional identifier for the statement. It takes an IRI and must
  // be unique for each statement in the document.
  optional string id = 1;

  // [vul_id] SHOULD use existing and well known identifiers, for example:
  // CVE, the Global Security Database (GSD), or a supplier’s vulnerability
  // tracking system. It is expected that vulnerability identification systems
  // are external to and maintained separately from VEX.
  //
  // [vul_id] MAY be URIs or URLs.
  // [vul_id] MAY be arbitrary and MAY be created by the VEX statement [author].
  optional VexVulnerability vulnerability = 2;

  // Timestamp is the time at which the information expressed in the Statement
  // was known to be true.
  optional string timestamp = 3;

  // LastUpdated records the time when the statement last had a modification
  optional string last_updated = 4;

  // Product
  // Product details MUST specify what Status applies to.
  // Product details MUST include [product_id] and MAY include [subcomponent_id].
  repeated Product products = 5;

  // A VEX statement MUST provide Status of the vulnerabilities with respect to the
  // products and components listed in the statement. Status MUST be one of the
  // Status const values, some of which have further options and requirements.
  optional string status = 6;

  // [status_notes] MAY convey information about how [status] was determined
  // and MAY reference other VEX information.
  optional string status_notes = 7;

  // For ”not_affected” status, a VEX statement MUST include a status Justification
  // that further explains the status.
  optional string justification = 8;

  // For ”not_affected” status, a VEX statement MAY include an ImpactStatement
  // that contains a description why the vulnerability cannot be exploited.
  optional string impact_statement = 9;

  // For "affected" status, a VEX statement MUST include an ActionStatement that
  // SHOULD describe actions to remediate or mitigate [vul_id].
  optional string action_statement = 10;

  optional string action_statement_timestamp = 11;
}

message StatusBase {
  optional ConditionedStatus conditionedStatus = 1;

  optional string status = 2;
}

message Subcomponent {
  optional Component component = 1;
}

message SyftCoordinates {
  optional string path = 1;

  optional string layerID = 2;
}

// SyftDescriptor describes what created the document as well as surrounding metadata
message SyftDescriptor {
  optional string name = 1;

  optional string version = 2;

  optional bytes configuration = 3;
}

// SyftDocument represents the syft cataloging findings as a JSON document
message SyftDocument {
  repeated SyftPackage artifacts = 1;

  // Artifacts is the list of packages discovered and placed into the catalog
  repeated SyftRelationship artifactRelationships = 2;

  repeated SyftFile files = 3;

  // note: must have omitempty
  optional SyftSource source = 4;

  // SyftSource represents the original object that was cataloged
  optional LinuxRelease distro = 5;

  // Distro represents the Linux distribution that was detected from the source
  optional SyftDescriptor descriptor = 6;

  // SyftDescriptor is a block containing self-describing information about syft
  optional Schema schema = 7;
}

message SyftFile {
  optional string id = 1;

  optional Coordinates location = 2;

  optional FileMetadataEntry metadata = 3;

  optional string contents = 4;

  repeated Digest digests = 5;

  repeated FileLicense licenses = 6;

  optional Executable executable = 7;
}

// SyftPackage represents a pkg.SyftPackage object specialized for JSON marshaling and unmarshalling.
message SyftPackage {
  optional PackageBasicData packageBasicData = 1;

  optional PackageCustomData packageCustomData = 2;
}

message SyftRelationship {
  optional string parent = 1;

  optional string child = 2;

  optional string type = 3;

  optional bytes metadata = 4;
}

// SyftSource object represents the thing that was cataloged
message SyftSource {
  optional string id = 1;

  optional string name = 2;

  optional string version = 3;

  optional string type = 4;

  optional bytes metadata = 5;
}

// Syscall defines a syscall in seccomp.
message Syscall {
  // the names of the syscalls
  repeated string names = 1;

  // the action for seccomp rules
  optional string action = 2;

  // the errno return code to use. Some actions like SCMP_ACT_ERRNO and
  // SCMP_ACT_TRACE allow to specify the errno code to return
  optional uint64 errnoRet = 3;

  // the specific syscall in seccomp
  repeated Arg args = 4;
}

// ToolMeta describes metadata about a tool that generated an artifact
message ToolMeta {
  optional string name = 1;

  optional string version = 2;
}

message UpstreamPackage {
  optional string name = 1;

  optional string version = 2;
}

message VEX {
  optional Metadata metadata = 1;

  repeated Statement statements = 2;
}

message VexVulnerability {
  //  ID is an IRI to reference the vulnerability in the statement.
  optional string id = 1;

  // Name is the main vulnerability identifier.
  optional string name = 2;

  // Description is a short free form text description of the vulnerability.
  optional string description = 3;

  // Aliases is a list of other vulnerability identifier strings that
  // locate the vulnerability in other tracking systems.
  repeated string aliases = 4;
}

message VulnerabilitiesComponents {
  optional VulnerabilitiesObjScope all = 1;

  optional VulnerabilitiesObjScope relevant = 2;
}

message VulnerabilitiesObjScope {
  optional string namespace = 1;

  optional string name = 2;

  optional string kind = 3;
}

message Vulnerability {
  optional VulnerabilityMetadata vulnerabilityMetadata = 8;

  optional Fix fix = 9;

  repeated Advisory advisories = 10;
}

// VulnerabilityCounters describes a counter of vulnerabilities.
//
// Intended to store relevant and total vulnerabilities in the future.
message VulnerabilityCounters {
  optional int64 all = 1;

  optional int64 relevant = 2;
}

// VulnerabilityManifest is a custom resource that describes a manifest of found vulnerabilities.
message VulnerabilityManifest {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional VulnerabilityManifestSpec spec = 2;

  optional VulnerabilityManifestStatus status = 3;
}

// VulnerabilityManifestList is a list of Vulnerability manifests.
message VulnerabilityManifestList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated VulnerabilityManifest items = 2;
}

// VulnerabilityManifestMeta holds metadata about a vulnerability manifest
message VulnerabilityManifestMeta {
  optional bool withRelevancy = 1;

  optional VulnerabilityManifestToolMeta tool = 2;

  optional VulnerabilityManifestReportMeta report = 3;
}

// VulnerabilityManifestReportMeta holds metadata about the specific report
// tied to a vulnerability manifest
message VulnerabilityManifestReportMeta {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time createdAt = 1;
}

message VulnerabilityManifestSpec {
  optional VulnerabilityManifestMeta metadata = 1;

  optional GrypeDocument payload = 2;
}

message VulnerabilityManifestStatus {
}

// VulnerabilityManifestSummary is a summary of a VulnerabilityManifest.
message VulnerabilityManifestSummary {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional VulnerabilityManifestSummarySpec spec = 2;

  optional VulnerabilityManifestStatus status = 3;
}

// VulnerabilityManifestSummaryList is a list of VulnerabilityManifest summaries.
message VulnerabilityManifestSummaryList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated VulnerabilityManifestSummary items = 2;
}

message VulnerabilityManifestSummarySpec {
  optional SeveritySummary severities = 1;

  optional VulnerabilitiesComponents vulnerabilitiesRef = 2;
}

// VulnerabilityManifestToolMeta describes data about the tool used to generate
// the vulnerability manifest’s report
message VulnerabilityManifestToolMeta {
  optional string name = 1;

  optional string version = 2;

  optional string databaseVersion = 3;
}

message VulnerabilityMetadata {
  optional string id = 1;

  optional string dataSource = 2;

  optional string namespace = 3;

  optional string severity = 4;

  repeated string urls = 5;

  optional string description = 6;

  repeated Cvss cvss = 7;
}

// VulnerabilitySummary is a summary of a vulnerabilities for a given scope.
message VulnerabilitySummary {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional VulnerabilitySummarySpec spec = 2;

  optional VulnerabilitySummaryStatus status = 3;
}

// VulnerabilitySummaryList is a list of VulnerabilitySummaries.
message VulnerabilitySummaryList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated VulnerabilitySummary items = 2;
}

message VulnerabilitySummarySpec {
  optional SeveritySummary severities = 1;

  repeated VulnerabilitiesObjScope vulnerabilitiesRef = 2;
}

message VulnerabilitySummaryStatus {
}

// WorkloadConfigurationScan is a custom resource that describes a configuration scan result of a workload.
message WorkloadConfigurationScan {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional WorkloadConfigurationScanSpec spec = 2;
}

// WorkloadConfigurationScanList is a list of workload configuration scan results.
message WorkloadConfigurationScanList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated WorkloadConfigurationScan items = 2;
}

message WorkloadConfigurationScanSeveritiesSummary {
  optional int64 critical = 1;

  optional int64 high = 2;

  optional int64 medium = 3;

  optional int64 low = 4;

  optional int64 unknown = 5;
}

message WorkloadConfigurationScanSpec {
  map<string, ScannedControl> controls = 2;

  repeated WorkloadScanRelatedObject relatedObjects = 3;
}

// WorkloadConfigurationScanSummary is a summary of a WorkloadConfigurationScan
message WorkloadConfigurationScanSummary {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional WorkloadConfigurationScanSummarySpec spec = 2;
}

// WorkloadConfigurationScanSummaryIdentifier includes information needed to identify a WorkloadConfigurationScanSummary object
message WorkloadConfigurationScanSummaryIdentifier {
  optional string namespace = 1;

  optional string kind = 2;

  optional string name = 3;
}

// WorkloadConfigurationScanSummaryList is a list of WorkloadConfigurationScan summaries.
message WorkloadConfigurationScanSummaryList {
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated WorkloadConfigurationScanSummary items = 2;
}

message WorkloadConfigurationScanSummarySpec {
  optional WorkloadConfigurationScanSeveritiesSummary severities = 1;

  map<string, ScannedControlSummary> controls = 2;
}

message WorkloadScanRelatedObject {
  optional string namespace = 1;

  optional string apiGroup = 2;

  optional string apiVersion = 3;

  optional string kind = 4;

  optional string name = 5;
}

